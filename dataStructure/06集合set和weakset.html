<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        //es6中的set
        var s=new Set();
        s.add(1);
        s.add(2);
        s.add(3);
        //集合
        s.forEach(function(value1,value2,set){
            //集合中每一项和索引一样
            console.log("value1-",value1);
            console.log("value2-",value2);
            console.log("set-",set);
        });
        //数组
        var arr=["a","b","c"];
        arr.forEach(function(item,index){
            //item 数组存储的值 index 对应的下标
            console.log(item,index);
        });

        //获得迭代器
        var iterator=s.entries();
        console.log(iterator.next().value);
        console.log(iterator.next().value);
        console.log(iterator.next().value);

        //集合之解构
        var a=[1,2,3];
        var b=[2,3,4];
        var union=new Set([...a,...b]);
        console.log(union);
        //数组之解构
        var c=[...a,...b];
        console.log(c);

        //传统
        var arr1=[1,-2,3,-4,10];
        //把大于0的数拿出来
        var arr2=[];
        for(var i=0;i<arr.length;i++){
            if(arr[i]>0){
                arr2.push(arr[i]);
            }
        }
        console.log(arr2);
        //es6 filter(fn)
        //fn 返回true 则添加到返回数组里
        arr2=arr1.filter(function(value){
            if(value>0){
                return true;
            }
        });
        console.log(arr2+"普通函数");
       
        //箭头函数
        arr2=arr1.filter(value=>{
            if(value>0){
                return true;
            }
        });
        
        console.log(arr2+"箭头函数");

        var s1=new Set();
        s1.add(1);
        s1.add(2);
        s1.add(3);
        var s2=new Set();
        s2.add(2);
        s2.add(3);
        s2.add(4);

        // var intersect=new Set([...s1].filter(
        //     function(x){
        //         return s2.has(x)
        //     }
        // ))
       var intersect=new Set([...s1].filter(x=>s2.has(x)));
       var different=new Set([...s1].filter(x=>!s2.has(x)));
      console.log(intersect);
       console.log(different);
       //setnull前没有被其他变量引用，则被js内存回收机制回收
       //set强引用（null前被其他变量引用，其并没有被内存回收，除非delate），weakset弱引用（null前被其他变量引用，其并被内存回收） 
    </script>
</body>
</html>
